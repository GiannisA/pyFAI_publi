\documentclass[preprint]{iucr}
 \journalcode{J}
 \papertype{CP}

\usepackage{graphicx}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\begin{document}

\title{The Fast Azimuthal Integration Python library}
\shorttitle{PyFAI}

    \author[a]{Aurore}{Deschildre}
    \author[a]{Giannis}{Ashiotis}
    \author[b]{Zubair}{Nawaz}
    \author[a]{Jonathan P.}{Wright}
    \author[a]{Dimitrios}{Karkoulis}
    \author[c]{Fr\'ed\'eric-Emmanuel}{Picca}
    \cauthor[a]{J\'er\^ome}{Kieffer}{jerome.kieffer@esrf,fr}{}
    \aff[a]{European Synchrotron Radiation Facility, \city{Grenoble}, \country{France}}
    \shortauthor{Kieffer et al.}

\maketitle

\begin{synopsis}

\end{synopsis}

\begin{abstract}
\end{abstract}

\section{Introduction}
Azimuthal integration allows using area detectors for recording powder
diffraction patterns, which  ensure larger solid angle coverage and hence a better harvest of X­ray photons. 
This data reduction 
step is one of the most time ­consuming tasks in the processing pipeline and
sometimes limits the productivity of modern synchrotron beamlines, where
diffraction is used to probe samples with a  pencil beam in 2D raster scans or
diffraction tomography experiments by using very fast detectors. 

This contribution describes the Python library pyFAI in its version 0.10 (fall
2014) which can be used to calibrate the experimental setup of a powder
diffraction experiment or a SAXS experiement using area detector using
Debye-Scherrer rings of a reference compound. 
Afer describing how the geometry is internally represented, the various
image analysis algorithm used to extract Debye-Scherrer rings are presented.
Those ring positions are combined with a calibrant to perform the refinement
of the geometry.

Once this geometry known, azimuthal regrouping can be performed. 
PyFAI implements various algorithm for intergrating with various pixel splitting
schemes which will be exposed. 
The latest algorithms have been optimized for
manycore computer devices, they are benchamarked with previous implementation on
many classes of devices.

Finally some scientific examples are given on how pyFAI can be used to decompose 
diffraction images into amorphous and Bragg component and its application
to serial crystallography.
 
\section{Experiment description}
In pyFAI, a basic experiment is defined by an area-detector which position in
space is defined versus the intersection of the incoming pencil beam and the
sample plan.

\subsection{Detector}
Like most other image processing packages, pyFAI allows the definition of 2D
detectors by a constant pixel size (in meter) but this approach shows its limits
with various types of detectors.
Large area pixel detector are often composed from the assembly of smaller
modules (Pilatus from Dectris, Maxipix from ESRF, \ldots). 
By construction, such detector exhibit gaps between modules and pixels of
various sizes within a module, hench requires a specific mask.
Optically coupled CCD detector should also be corrected
for small spacial displacement of the pixel, often called geometric distortion.

\subsubsection{Detectors classes} are used to define a familly of detectors/ 
To take the specificites of each detector into account, pyFAI contains about
40 detectors class definition which contains the mask (invalid pixels, gaps,
\ldots) and a method to calculate the pixel position in cartesian coordinates.
For tapper coupled CCD detectors, the geometrical distortion is often
described as a bi-dimentional cubic spline and save in a so called ``spline
file''. 
Such files have been introduced by FIT2D \cite{fit2d} and are still widely
used. PyFAI can create a detector description by loading into a ``FReLon''
detector object

\subsubsection{Nexus Detectors}
Any detector object in PyFAI, can be saved to a HDF5 file following the NeXus
conversion (slightly modified).
Detector objects can then be restored from the disk, making detector definition
less error-prone.
Pixels of a 2D detector are saved as a 4D HDF5-dataset: 2D array of vertices
pointing to every corner of each pixel, which makes an array of shape: (ny, nx, 4, 3)
This can define detectors no longer planar, like tiled detectors from
ImXpad or the Pilatus12M from Dectris, even accounting for the normal of each
pixel. 
While extremely flexible, this detector definition come at the cost of
large description files.

\subsection{Geometry}
The experiment geometry is defined in pyFAI by six parameters: the sample
detector distance along with the detector coordinates of the sample's orthogonal
projection on the detector plane, called PONI. 
The detector's rotation along the three axes are completing those six
parameters. 
All three distances are given in meter and all three rotation are given
in radians.
Those S.I. units may look inaddapted or odd to users familiar to other code
like FIT2D \cite{fit2d} or SPD \cite{spd}, therefore the geometry can be
exported to (or imported from) other software.

 
\subsubsection{Binning}
One of the strength of this geometry is capability to perform binning of the
detector without having to re-calibrate or re-calculate the position in space.
All pyFAI detector classes have a binning option which will increase the pixel
size accordingly and divide detector shape accordingly. 
This even works for detectors with distortion files. 

\section{Calibration}
Calibration of the position of the detector is performed using Debye-Scherrer
rings collected from a reference powder called ``calibrant''.
Rings are extracted and control points are located as maxima of those rings.
The geometry of the experiment is obtained from a least-squares refinement of
the $2\theta$ angles.
In this contribution we will call them ``ring'' even if, for planar detector,
they are actually conics formed by the intersection of the Debye-Scerrer cones
with the detector plan. 
PyFAI does not assume rings are circles, ellipses or parabola and is able to fit
any kind of geometry. The support for the geometry refinement of non planar
detector is still under development.

\subsection{Calibrant}
PyFAI provides ten calibrants files among the most used ones: ceria, corundum,
gold, lantahnide hexaboride and silicon for powder diffraction; silver behenate,
tetradecanol and para-bromobenzoic acid for small angle scattering.
Any file containing d-spacing in angstrom can be used as calibrant for a
geometry calibration and can be loaded by the $Calibrant$ class instance.
This computer object is in charge of
calculating the reference $2\theta$ cone opening 
against which the geometry will be refined (provided the wavelength/energy is
known).

\subsection{Peak-picking}
With the nano-focused beam available on modern synchrotron facilities
\cite{id13}, fewer crystal get hit by the beam going through the
sample making Debye-Scherrer ring obtained from the diffraction of reference
powders spotty.
As grinding reference powder is not advices (it would at least broaden peaks if
not changing crystal structure), we decided to address this issue by image analysis 
and reconstruct Debye-Scherrer rings.
An alternative approach is to use single crystal indexation technics, for
example using the Fable software \cite{bonnin}.

\subsubsection{Massif extraction}
allows a clear separation between regions containing large
photon counts (rings) and the background.
It uses a difference of the image with itself, blured with a given width,
$\sigma$. 
Border of the regions with high intensity are negative in this
difference with a gaussian image, so positive region are labeled and represents
a ring (or a fraction of it). Peaks, which are local maxima, are sample within
the same region.
The width of the gaussian has to be larger than the typical distance
between two peaks within a ring and smaller than the distance between two
rings. 
PyFAI includes some heuristics to guess an acceptable parameter in most cases
but they can be overridden by the command line argument $--gaussian=XX$.

\subsubsection{Sub-pixel precision} 
on the peak position is obtained using a second order developemnt of the
intensity on the vinicy of the peak:
$$ I(\overrightarrow{x}) = I(\overrightarrow{x_0}) + \nabla
I(\overrightarrow{x_0})\cdot (\overrightarrow{x}-\overrightarrow{x_0}) +
\frac{1}{2} (\overrightarrow{x}-\overrightarrow{x_0})^T\cdot\mathcal{H}
I(\overrightarrow{x_0})\cdot(\overrightarrow{x}-\overrightarrow{x_0})$$ which
can be derived into:
$$\nabla I(\overrightarrow{x}) =\nabla I(\overrightarrow{x_0}) +
\mathcal{H}I(\overrightarrow{x_0})\cdot(\overrightarrow{x}-\overrightarrow{x_0})$$
Extrema are define by $\nabla I(\overrightarrow{x})=0$, hence:
$$\overrightarrow{x} = \overrightarrow{x_0} - (\mathcal{H}
I(\overrightarrow{x_0}))^{-1}\cdot\nabla I(\overrightarrow{x_0})$$ where $I$,
$\nabla I$ and $\mathcal{H} I$ are the scalar field of intensity, its gradient
(vector) and hessian (matrix), respectively, measured at the maximum pixel position.
\subsubsection{Blob detection}

\subsection{User interface}

\subection{Automatic distance calibration}


\section{Integration}

\subsection{Pixel splitting schemes}

\subsubsection{No splitting}

\subsubsection{Bounding box splitting}

\subsubsection{Tight pixel splitting}

\subsubsection{Pixel correlation}

It is worth mentionning that direct histogram without pixel splitting is the
only method which allows precise measurement of the error\cite{billinge2014}.

\subsection{User interface}

\section{Signal separation}

\subsection{Diffraction image generation}

Once the geometry defined, the $2\theta$ and $\chi$ position of every single
pixel of the detector are known.
If one assumes the isotropy of signal (real powder without prefered
orientation), $2D$ diffraction patterns can be generated.
The method, $calcfrom1d$ is available from any $Azimuthal Integrator$ or
$Geometry$ instance, is used together with a calibrant object
to generate a fake diffraction image suitable for testing pyFAI or other 
calibration codes (for example to validate the geometry translation from one
program to another).

\begin{verbatim}
import pyFAI, pyFAI.calibrant
det = pyFAI.detectors.detector_factory("pilatus1m")
ai = pyFAI.AzimuthalIntegrator(dist=0.1, poni1=0.1, poni2=0.1, detector=det)
lab6 = pyFAI.calibrant.ALL_CALIBRANTS["LaB6"]
lab6.set_wavelength(1e-10)
img = lab6.fake_calibration_image(ai)
\end{verbatim}

In this sniplet of code, after importing the library, a detector is instancated
from its name (line 2) and positionned in space (line 3).
A reference sample is defined on line 4 from the known calibrants and the
wavelength is set on line 5. Line 6 generates a 2D numpy array containing
Debye-Scherrer diffraction ring which can be saved or displayed on the screen.

\subsection{Image offset and validation of the calibration}
By regenerating a 2D diffraction image from the integrated powder pattern one
can assess the quality of the calibration used for the integration.
The calibration tool, pyFAI-calib, offers  a ``validate'' command which measures
the offset on the image (x, y) between the 2D diffraction image and the one
regenerated from the integrated patern, using a phase correlation algorithm.
This allows a measurement of the precision of the PONI, which is often better
than a tenth of a pixel !
To obtain such a result, a proper calibration image with continuous rings (i.e.
not spotty) and a mask to remove the beam stop are mandatory.

\subsection{Amorphous background removal}

PyFAI's azimuthal integrator features a $separate$ method able to separate
the backgound with an azimuthal symmetry (amorphous scattering or powder ring),
from Bragg peaks automatically.

Based on what was described in \cite{PyFAI_PDJ}, a bidimentional azimuthal
integration is performed on the input image.
The output 2D image is filtered out along the azimuthal $\chi$ axis using a
percentile filter to construct the powder diffraction curve without the punctual
Bragg spots.
The number of points in azimuthal and radial direction as well as
the percentile value can be adjusted but the default values are reasonnably
good.

The reconstructed 2D image corresponds to the amorphous/powder/isotropic
composant of the input image and the subtraction of this generated image from
the raw data contains only the bragg signal.
Figure \ref{separate} (left)
presents a close-up look at the first image of a Lysozyme dataset provided by Dectris to
advertize their Pilatus 6M detectors (image taken at the Swiss Light Source). A
moderate ice-ring is clearly visible. After using the automatic amorphous
background removal, which takes into account the mask needed for such pixel
detector, only Bragg peaks remains (right of the image).

\begin{figure}
\label{separate}
\begin{center}
\includegraphics[width=15cm]{separate.eps}
\caption{Automatic separation of amorphous signal from Bragg peaks in a
protein crystallography experiment.}
\end{center}
\end{figure}

\subsubsection{Application to high-pressure diffraction}
When high-pressure diffraction is performed using diamond anvil cells, the Bragg
reflection from diamond tend to polluted the powder diffraction signal. PyFAI's
isotropic component separation can also be used to retieve the powder signal and
discard the signal from the the diamond.

\subsubsection{Application to serial crystallography}
In those experiment, tiny crystals in their medium (liquid) are sent in front of
the X-ray beam (using a jet or moving a motor) and data are acquired
continuously, using a fast detector (from dozens of Hertz to kHz).
Those experiment produce a huge amount of data and only a small fraction of the
frames contain actually diffraction signal.
PyFAI, when integrated into the LImA data acquisition system \cite{lima},
can be used to assess the amount of single crystall diffraction data and decide
to save or not any frame, saving a huge amount of disk space and network
bandwidth.



\section{Conclusion}




\bibliographystyle{iucr}
\bibliography{biblio}
\appendix
\section{Project structure}
PyFAI is an open source project licensed under the GPL mainly written in Python (v2.6 or 2.7)
and heavily relying on the python scientific ecosystem: NumPy, SciPy and Matplotlib.
It provides high performances image treatment thanks to Cython and PyOpenCL.

The project is hosted on GitHub (https://github.com/kif/pyFAI) which provides
the issue tracker in addition to code hosting.
To ease the distribution, the
software is available as official Debian package and included in some of the
most famous linux distribution like Ubuntu and Debian.
The program runs also on other operating systems like Windows and MacOSX.

Anybody can fork the project and adapt it to his own needs: CEA-saclay,
Synchrotrons Soleil and APS did it. If developments are useful to be shared,
they can be merged into the main branch via pull-requests.

\section{Parallel implementations using OpenCL}
Azimuthal integration and many other computing parts in pyFAI were written in
OpenCL kernels and interfaced using PyOpenCL \cite{pyopencl}. PyOpenCL offers a
shared execution model effective both on processors (CPU), graphics cars (GPU)
and accelerators like the Intel's Xeon Phi.

\subsection{Azimuthal Integration}
The direct azimuthal integration is basically a scatter operation which
requires large locked section.
To overcome this limitation, pixels have been
associated to the output bin of the histogram and stored in a look-up
table (LUT), making the integration look like a simple (if large and sparse)
matrix vector product.
The sparse matrix ``Compressed Sparse Row'' (CSR) format is now used in pyFAI,
saving about half of the space of the LUT previously used.
Secondly, all threads within a workgroup are collaborating to calculate the
matrix-vector product via a so-called ``parallel reduction'', offering
additional speed-up (especially on GPUs).
The compensated algebra (Kahan summation) is kept to maintain the precision
of the calculation while using single precision (32 bits) floating points
arithmetics.

\subsection{Look-up table creation}


\ack{Acknowledgements}

The author would like to thank all ESRF beamline teams for \ldots

In the instrumentation division (ISDD) we would like to thank Claudio Ferrero,
head of data analysis unit, and Andy G\"otz, head of software group, for
supporting the parallelization work on the presented algorithm.
V. Armando Solé, the author of PyMca, is also acknowledged for providing a

LinkSCEEM \ldots



\end{document}

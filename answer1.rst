Dear Referee 1,

Thank you for your review. We will try to answer your question and remarks.


Tilted detectors
----------------
As stated in the text, pyFAI has no issue dealing with highly tilted detectors.
As this was already described intensively in this article published in 2013:
http://dx.doi.org/10.1017/S0885715613000924 (see figure 3)
We did not emphasize on that aspect in this article.

Following your suggestion, the SAXS calibration image has been replaced with a WAXS
calibration image taken with a pixel-detector tilted of about 20 deg (no beam-stop on the image).
This Xpad detector exhibits large (vertical) gaps which sometimes eats-up rings, making such calibration
especially challenging.

Mathematical description
------------------------
All calculation about geometry have been made using Mathematica, which limits the human error.
This is available as part of source of the project so that anybody can check them:
https://github.com/kif/pyFAI/blob/master/geometry/pyFAI_geometry.txt

The detector's origin is initially located at the sample's position (origin), orthogonal to the beam.
The detector is then translated to be at the correct distance and having the incident beam hitting at the PONI
coordinates.

Three rotations along the vertical, horizontal and incident beam axis are then subsequently applied to the detector,
rotations around the origin (sample position).

Any pixel (i,j) on the detector has to be rotated accordingly to get its position in space (t1,t2,t3).
The calculation of the 2theta, q, or azimuthal angle is then as easy as :

tth = atan2(sqrt(t1*t1 + t2*t2), t3)
chi = atan2(t2,t1)

But the formula becomes then "huge" when written as function of (i,j) and the parameters: dist, poni1, poni2, rot1, rot2, rot3.

Python library
--------------

As you stated most (>90%)of the code appears to be C (and not C++) according to simple code analysis tools like:
https://www.openhub.net/p/pyFAI

But the code distribution is be biased as all the C code is actually generated by "Cython".
In the documentation, we summarized the actual code distribution:
 https://github.com/kif/pyFAI/blob/master/doc/source/operations/project.rst

* 14000 lines of Python (plus 4300 for the test)
* 8500 lines of Cython which are converted into ...
* 3500 lines of OpenCL kernels

In this sense, pyFAI is a Python library with most of the code actually written in Python (Cython being an extension of Python)

I would highlight that this approach has been taken by many projects like scikit-learn and scikit-image:
having a smaller code-base in Python+Cython makes the project easier to maintain compared to large chunks of C (or Fortran) which makes SciPy hard to maintain and make evolve.

Once again, thanks for your constructive review.
We hope to have addressed your comment.

Best regards,

Jerome Kieffer.
